#!/usr/bin/env python3
import rospy
import numpy as np
import threading
from reciprocal_vel_obs import reciprocal_vel_obs
from gazebo_msgs.msg import WorldState
from gazebo_msgs.msg import ModelStates
from geometry_msgs.msg import Twist
from geometry_msgs.msg import Pose
from std_msgs.msg import String
from math import atan2
from reciprocal_vel_obs import reciprocal_vel_obs
import torch
import sys
from math import sin, cos, pi
import re 
import time

num_robot = 12
robot_name_list = ['agent1', 'agent2','agent3','agent4','agent5', 'agent6', 'agent7','agent8','agent9','agent10', 'agent11', 'agent12']

#12
goal_list1 = [[9.5, 8], [8, 8], [6.5, 8], [5, 8], [3.5, 8], [2, 8],  [2, 2], [3.5, 2], [5, 2], [6.5, 2], [8, 2], [9.5, 2]]
goal_list = [[2, 2], [3.5, 2], [5, 2], [6.5, 2], [8, 2], [9.5, 2],  [9.5, 8], [8, 8], [6.5, 8], [5, 8], [3.5, 8], [2, 8]]

# 4
# goal_list1 = [[2, 3] , [5, 3], [2, 9], [5, 9]]
# goal_list = [[5, 9] , [2, 9], [5, 3], [2, 3] ]

# 8

# goal_list = [[2, 2], [3.5, 2], [5, 2], [6.5, 2], [2, 7] , [3.5, 7], [5, 7], [6.5, 7]]
# goal_list1 = [[6.5, 7], [5, 7], [3.5, 7], [2, 7],[6.5, 2], [5, 2], [3.5, 2], [2, 2]]

v_max = 1
robot_radius = 0.2
robot_collision_radius = 0.4
neighbors_region = 4
w_max = 2

filename = '/home/han/catkin_ws/src/master_multirobot/master_planning/rl_rvo/project/rl_rvo_nav/ppo_save/model/move14/move14.pt'

pub=rospy.Publisher('/global/multi_vel', WorldState, queue_size=100)


def cal_des_omni(position, goal_position):

	dif_x = goal_position[0] - position[0]
	dif_y = goal_position[1] - position[1]

	dis = np.sqrt( dif_x**2 + dif_y**2 )
	radian = atan2(dif_y, dif_x)

	if dis > 0.3:
		vx = v_max * cos(radian)
		vy = v_max * sin(radian)

	else:
		vx = 0
		vy = 0
	
	return vx, vy

def cal_yaw(quater):

	x = quater.x
	y = quater.y
	z = quater.z
	w = quater.w

	yaw = atan2(2 * (w * z + x * y), 1 - 2 * (pow(z, 2) + pow(y, 2)))

	return yaw

# def cal_des_vel_diff(self, tolerance = 0.12):

# 	dis, radian = mobile_robot.relative(self.state[0:2], self.goal)
# 	robot_radian = self.state[2, 0]

# 	w_opti = 0

# 	v_max = self.vel_max[0, 0]
# 	w_max = self.vel_max[1, 0]

# 	diff_radian = mobile_robot.to_pi( radian - robot_radian )

# 	if diff_radian > tolerance:
# 		w_opti = w_max
	
# 	elif diff_radian < - tolerance:
# 		w_opti = - w_max    

# 	if dis < self.goal_threshold:
# 		v_opti = 0
# 		w_opti = 0
# 	else:
# 		v_opti = v_max * cos(diff_radian)
		
# 		if v_opti < 0:
# 			v_opti = 0

# 	return np.array([[v_opti], [w_opti]])


def omni2diff(vel_x, vel_y, robot_radians, guarantee_time = 0.2, tolerance = 0.1):

	speed = np.sqrt(vel_x ** 2 + vel_y ** 2)
	vel_radians = atan2(vel_y, vel_x)
	
	diff_radians = robot_radians - vel_radians

	if diff_radians > pi:
		diff_radians = diff_radians - 2*pi
	elif diff_radians < -pi:
		diff_radians = diff_radians + 2*pi

	if diff_radians < tolerance and diff_radians > -tolerance:
		w = 0
	else:
		w = -diff_radians / guarantee_time
		if w > w_max:
			w = w_max
		
	v = speed * cos(diff_radians)

	if v<0:
		v = 0
	
	if speed == 0:
		v = 0
		w = 0

	return v, w


def load_policy(filename, std_factor=1):

    model = torch.load(filename)
    model.eval()
    def get_action(x):
        with torch.no_grad():
            x = torch.as_tensor(x, dtype=torch.float32)
            action = model.act(x, factor=std_factor)
        return action

    return get_action


model = torch.load(filename)
model.eval()

# get_action = load_policy(filename, std_factor=0.001)

moving_state_list = [None] * num_robot
robot_state_list = [None] * num_robot
name_list = [None] * num_robot
pose_list=[None] * num_robot
obs1_list = [None] * num_robot
yaw_list = [None] * num_robot

def callback(data):
	start_time = time.time()
	
	for index, name in enumerate(data.name):
		
		if name in robot_name_list:
			id_agent = int(re.findall('\d+', name)[0])
			
			p_x = data.pose[index].position.x
			p_y = data.pose[index].position.y

			vel_x = data.twist[index].linear.x
			vel_y = data.twist[index].linear.y

			yaw = cal_yaw(data.pose[index].orientation)

			collision_range = robot_collision_radius

			moving_state = np.array([p_x, p_y, vel_x, vel_y, collision_range])
			moving_state_list[id_agent - 1] = moving_state

			goal_position = goal_list[id_agent-1]
			des_x, des_y = cal_des_omni([p_x, p_y], goal_position)

			robot_state = np.array([p_x, p_y, vel_x, vel_y, robot_collision_radius, des_x, des_y])
			obs1 = np.array([vel_x, vel_y, des_x, des_y, robot_collision_radius])

			robot_state_list[id_agent - 1] = robot_state
			obs1_list[id_agent - 1] = obs1
			name_list[id_agent - 1] = name

			yaw_list[id_agent - 1] = yaw
			pose_list[id_agent - 1] = data.pose[index]

		# action = get_action(obs)
		# abs_action = 0.5 * action + np.array([vel_x, vel_y])
		# abs_action_list.append(abs_action)


	# for i in range(num_robot):
	# 	robot_name = name_list[i]
		
	# 	tw = Twist()

	# 	robot_state = robot_state_list[i]
	# 	des_x = robot_state[5]
	# 	des_y = robot_state[6]

	# 	# yaw = yaw_list[i]

	# 	# v, w = omni2diff(des_x, des_y, yaw)

	# 	# tw.linear.x = abs_action_list[i][0]
	# 	# tw.linear.y = abs_action_list[i][1]
	# 	# tw.linear.z = 0

	# 	tw.linear.x = des_x
	# 	tw.linear.y = des_y
	# 	tw.linear.z = 0

	# 	# tw.linear.x = v
	# 	# tw.angular.z = w
	# 	# tw.linear.z = 1

	# 	robot_pose = pose_list[i]

	# 	ws.name.append(robot_name)
	# 	ws.twist.append(tw)
	# 	ws.pose.append(robot_pose)


	# print('publish velocity successfully')
		#     if name == robot_name:     
		#         
		#     else: 
		#         other_position = data.pose[index].position
		#         other_vel = data.twist[index]

# other_list_position.append(other_position)
		#         other_list_vel.append(other_vel)

def rl_rvo():
	rospy.init_node('rl_rvo', anonymous=True)
	
	rate=rospy.Rate(50)
	rospy.Subscriber("/gazebo/model_states", ModelStates, callback)
	
	while not rospy.is_shutdown():
		ws = WorldState()
		for i in range(num_robot):
			
			if moving_state_list[0] is None:
				continue

			moving_state_list2 = moving_state_list[:]
			robot_state = robot_state_list[i]
			name = name_list[i]
			
			del moving_state_list2[i]
			
			p_x = robot_state[0]
			p_y = robot_state[1]
			vel_x = robot_state[2]
			vel_y = robot_state[3]
			des_x = robot_state[5]
			des_y = robot_state[6]

			def rs_function(moving_state):
				
				dif_x = moving_state[0] - p_x
				dif_y = moving_state[0] - p_y
				dis = np.sqrt( dif_x**2 + dif_y**2)

				return dis

			filter_moving_list = list(filter(lambda m: rs_function(m) <= neighbors_region, moving_state_list2))
			sorted_moving_list = sorted(filter_moving_list, key=lambda m: rs_function(m))

			rvo = reciprocal_vel_obs(robot_state, sorted_moving_list, vxmax = 1.5, vymax = 1.5)
			rvo_list = rvo.config_rvo2()
			vo_flag, min_dis = rvo.vo_out2(vel_x, vel_y, rvo_list)
			
			if min_dis > neighbors_region:
				min_dis = neighbors_region

			if len(rvo_list) == 0:
				rvo_array_flat = np.zeros(8,)
			else:
				rvo_array = np.concatenate(rvo_list)
				rvo_array_flat = rvo_array.flatten()

			obs1 = obs1_list[i]
			obs = np.concatenate((obs1, rvo_array_flat)) 

			# with torch.no_grad():
			obs = torch.as_tensor(obs, dtype=torch.float32)
			action = model.act(obs, factor=0.0001)
			abs_action = 0.5 * action + np.array([vel_x, vel_y])


			robot_name = name_list[i]
		
			tw = Twist()
			# v, w = omni2diff(des_x, des_y, yaw)

			if des_x == 0 and des_y == 0:
				tw.linear.x = 0
				tw.linear.y = 0
				tw.linear.z = 0

				
			else:

				tw.linear.x = abs_action[0]
				tw.linear.y = abs_action[1]
				tw.linear.z = 0

			# tw.linear.x = des_x
			# tw.linear.y = des_y
			# tw.linear.z = 0

			# tw.linear.x = v
			# tw.angular.z = w
			# tw.linear.z = 1

			robot_pose = pose_list[i]

			ws.name.append(robot_name)
			ws.twist.append(tw)
			ws.pose.append(robot_pose)

		pub.publish(ws)
		print('publish velocity successfully')
		rate.sleep()


def spin():
	rospy.spin()


if __name__=='__main__':
	thread = threading.Thread(target=spin)
	rl_rvo()
	thread.start()
	
	